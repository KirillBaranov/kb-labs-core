/**
 * @module @kb-labs/core-platform/adapters/logger
 * Structured logging with required context fields.
 *
 * Design philosophy:
 * - Service context (service, traceId, etc.) is set once via child()
 * - Log payload (message, attributes) is provided per log call
 * - TypeScript enforces required fields at compile time
 * - Backward compatible with existing ILogger interface
 */

/**
 * Log level enumeration
 */
export type LogLevel = "trace" | "debug" | "info" | "warn" | "error" | "fatal";

/**
 * Service context - set once at logger creation
 * These fields identify WHERE the log comes from
 */
export interface ServiceContext {
  /** Service name (required) - e.g., 'rest-api', 'workflow-engine', 'mind-engine' */
  service: string;

  /** Hostname or instance identifier (optional) */
  hostname?: string;

  /** Process ID (optional) */
  pid?: number;

  /** Environment (optional) - e.g., 'production', 'staging', 'development' */
  environment?: string;

  /** Version (optional) - service version */
  version?: string;
}

/**
 * Correlation context - for distributed tracing
 * These fields connect related logs across services
 */
export interface CorrelationContext {
  /** Trace ID - unique identifier for entire request flow */
  traceId?: string;

  /** Span ID - unique identifier for this service's portion of work */
  spanId?: string;

  /** Parent span ID - for nested spans */
  parentSpanId?: string;

  /** Request ID - for HTTP requests */
  requestId?: string;

  /** User ID - for user-initiated actions */
  userId?: string;

  /** Tenant ID - for multi-tenant systems */
  tenantId?: string;
}

/**
 * Log payload - provided with each log call
 */
export interface LogPayload {
  /** Human-readable message (optional - can log structured data only) */
  message?: string;

  /** Structured attributes (optional) */
  attributes?: Record<string, unknown>;

  /** Error object (for error level only) */
  error?: Error;
}

/**
 * Complete log record structure
 */
export interface LogRecord {
  // === System fields (auto-generated) ===
  /** Unique log ID (generated by persistence layer) */
  id?: string;

  /** Timestamp (milliseconds since epoch) */
  timestamp: number;

  /** Log level */
  level: LogLevel;

  // === Service context (from child bindings) ===
  /** Service name */
  service: string;

  /** Hostname */
  hostname?: string;

  /** Process ID */
  pid?: number;

  /** Environment */
  environment?: string;

  /** Service version */
  version?: string;

  // === Correlation context (from child bindings or per-log) ===
  /** Trace ID */
  traceId?: string;

  /** Span ID */
  spanId?: string;

  /** Parent span ID */
  parentSpanId?: string;

  /** Request ID */
  requestId?: string;

  /** User ID */
  userId?: string;

  /** Tenant ID */
  tenantId?: string;

  // === Log payload (from log call) ===
  /** Human-readable message */
  message?: string;

  /** Structured attributes */
  attributes?: Record<string, unknown>;

  // === Extracted fields (for indexing in storage) ===
  /** Error type (extracted from attributes.errorType or error.name) */
  errorType?: string;

  /** Error message (extracted from error object) */
  errorMessage?: string;

  /** Error stack trace (extracted from error object) */
  errorStack?: string;
}

/**
 * Logger interface with required service context.
 *
 * Usage pattern:
 * ```typescript
 * // 1. Create base logger with service context (done once at app startup)
 * const baseLogger = createLogger({
 *   service: 'rest-api',
 *   hostname: os.hostname(),
 *   environment: 'production',
 * });
 *
 * // 2. Create child logger with correlation context (per request)
 * const requestLogger = baseLogger.child({
 *   traceId: req.headers['x-trace-id'],
 *   requestId: req.headers['x-request-id'],
 * });
 *
 * // 3. Log with payload (per log call)
 * requestLogger.info('User login', { userId: 123, method: 'oauth' });
 * ```
 */
export interface ILogger {
  /**
   * Log info message.
   * @param payload - Log payload (message and/or attributes)
   */
  info(payload: LogPayload): void;
  /** Convenience overload: info(message, attributes?) */
  info(message: string, attributes?: Record<string, unknown>): void;

  /**
   * Log warning message.
   * @param payload - Log payload
   */
  warn(payload: LogPayload): void;
  /** Convenience overload */
  warn(message: string, attributes?: Record<string, unknown>): void;

  /**
   * Log error message.
   * @param payload - Log payload with error object
   */
  error(payload: LogPayload & { error?: Error }): void;
  /** Convenience overload */
  error(
    message: string,
    error?: Error,
    attributes?: Record<string, unknown>,
  ): void;

  /**
   * Log debug message.
   * @param payload - Log payload
   */
  debug(payload: LogPayload): void;
  /** Convenience overload */
  debug(message: string, attributes?: Record<string, unknown>): void;

  /**
   * Log trace message (most verbose).
   * @param payload - Log payload
   */
  trace(payload: LogPayload): void;
  /** Convenience overload */
  trace(message: string, attributes?: Record<string, unknown>): void;

  /**
   * Log fatal message.
   * @param payload - Log payload
   */
  fatal(payload: LogPayload): void;
  /** Convenience overload */
  fatal(message: string, attributes?: Record<string, unknown>): void;

  /**
   * Create a child logger with additional context.
   *
   * Child loggers inherit parent context and add new bindings.
   * All logs from child logger will include both parent and child context.
   *
   * @param context - Additional context (service, correlation, or custom fields)
   *
   * @example
   * ```typescript
   * // Add correlation context per request
   * const requestLogger = logger.child({
   *   traceId: 'abc-123',
   *   requestId: 'req-456',
   *   userId: '789',
   * });
   *
   * // Add custom context for a specific operation
   * const operationLogger = requestLogger.child({
   *   operation: 'create_document',
   *   documentId: 'doc-xyz',
   * });
   * ```
   */
  child(
    context: Partial<
      ServiceContext & CorrelationContext & Record<string, unknown>
    >,
  ): ILogger;

  /**
   * Get log buffer for streaming/querying (optional feature).
   * @returns Log buffer if enabled, undefined otherwise
   */
  getLogBuffer?(): ILogBuffer | undefined;

  /**
   * Register callback for every log event (optional feature).
   * Used by platform to connect logger extensions (ring buffer, persistence).
   *
   * @param callback - Function to call on each log event
   * @returns Unsubscribe function
   */
  onLog?(callback: (record: LogRecord) => void): () => void;
}

/**
 * Query filters for log retrieval
 */
export interface LogQuery {
  /** Filter by log level(s) */
  level?: LogLevel | LogLevel[];

  /** Filter by service name(s) */
  service?: string | string[];

  /** Filter by trace ID */
  traceId?: string;

  /** Filter by request ID */
  requestId?: string;

  /** Filter by user ID */
  userId?: string;

  /** Filter by tenant ID */
  tenantId?: string;

  /** Filter by error type */
  errorType?: string;

  /** Start timestamp (milliseconds since epoch) */
  from?: number;

  /** End timestamp (milliseconds since epoch) */
  to?: number;

  /** Full-text search in message */
  search?: string;

  /** Maximum number of logs to return */
  limit?: number;

  /** Offset for pagination */
  offset?: number;
}

/**
 * Log buffer interface for streaming/querying logs
 */
export interface ILogBuffer {
  /** Append log record to buffer */
  append(record: LogRecord): void;

  /** Query logs with filters */
  query(query?: LogQuery): LogRecord[];

  /** Subscribe to real-time log stream */
  subscribe(
    callback: (record: LogRecord) => void,
    filters?: LogQuery,
  ): () => void;

  /** Get buffer statistics */
  getStats(): {
    total: number;
    bufferSize: number;
    oldestTimestamp: number | null;
    newestTimestamp: number | null;
  };
}

/**
 * Log persistence interface for storing logs
 */
export interface ILogPersistence {
  /** Write single log record */
  write(record: LogRecord): Promise<void>;

  /** Write multiple log records (batch) */
  writeBatch(records: LogRecord[]): Promise<void>;

  /** Query logs from storage */
  query(
    filters: LogQuery,
    options?: { sortOrder?: "asc" | "desc" },
  ): Promise<{
    logs: LogRecord[];
    total: number;
    hasMore: boolean;
  }>;

  /** Get log by ID */
  getById(id: string): Promise<LogRecord | null>;

  /** Search logs by text (full-text search) */
  search(
    searchText: string,
    options?: { limit?: number; offset?: number },
  ): Promise<{
    logs: LogRecord[];
    total: number;
  }>;

  /** Delete logs older than timestamp */
  cleanup(olderThan: number): Promise<{ deleted: number }>;

  /** Get storage statistics */
  getStats(): Promise<{
    totalRecords: number;
    oldestTimestamp: number | null;
    newestTimestamp: number | null;
    sizeBytes?: number;
  }>;
}
