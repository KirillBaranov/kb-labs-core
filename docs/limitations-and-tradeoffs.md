# Ограничения и компромиссы системы кросс-плагинных вызовов

## Текущие минусы и ограничения

### 1. Производительность

#### IPC Overhead (в subprocess режиме)
- **Проблема**: В production режиме (subprocess) брокеры нужно передавать через IPC
- **Текущее состояние**: Работает только в dev режиме (in-process)
- **Влияние**: 
  - Каждый `invoke()` требует IPC коммуникацию
  - Сериализация/десериализация данных
  - Задержка на каждый вызов: ~10-50ms дополнительно
- **Решение**: Нужно реализовать IPC для subprocess режима

#### Изоляция = Новые процессы
- **Проблема**: Каждый `invoke()` создает новый child process
- **Влияние**:
  - Overhead на создание процесса: ~50-100ms
  - Потребление памяти: каждый процесс ~50-100MB
  - При цепочке A→B→C→D = 4 процесса одновременно
- **Компромисс**: Безопасность vs производительность

#### Проверка прав на каждый вызов
- **Проблема**: Проверка разрешений происходит синхронно при каждом `invoke()`
- **Влияние**:
  - Парсинг манифеста
  - Сопоставление путей с паттернами (minimatch)
  - Проверка цепочек (visited[], depth, fanOut)
- **Задержка**: ~1-5ms на каждый вызов
- **Решение**: Можно кэшировать разрешения, но это усложняет систему

### 2. Сложность настройки

#### Манифест становится сложнее
- **Проблема**: Нужно явно указывать все разрешения
- **Пример**:
  ```json
  {
    "permissions": {
      "invoke": {
        "routes": [
          { "target": "@kb-labs/mind:POST /query" }
        ]
      },
      "artifacts": {
        "read": [
          { "from": "@kb-labs/mind", "paths": ["context/**"] }
        ],
        "write": [
          { "to": "self", "paths": ["out/**"] }
        ]
      }
    }
  }
  ```
- **Влияние**: 
  - Нужно понимать формат разрешений
  - Легко забыть добавить разрешение
  - Ошибки прав не всегда очевидны

#### Версионирование плагинов
- **Проблема**: Формат `@pluginId@version:METHOD /path` требует понимания semver
- **Пример**: `@kb-labs/mind@^1.2.0:POST /query`
- **Влияние**: 
  - Нужно знать версии плагинов
  - Несовпадение версий → ошибка
  - Сложнее отладка

### 3. Ограничения функциональности

#### Нет асинхронных вызовов
- **Проблема**: Все `invoke()` синхронные (await)
- **Влияние**: 
  - Нельзя запустить несколько плагинов параллельно (без Promise.all)
  - Цепочка A→B→C выполняется последовательно
  - Если B медленный → блокирует C
- **Решение**: Можно использовать Promise.all, но нужно быть осторожным с fanOut лимитом

#### Нет очереди сообщений
- **Проблема**: Нет механизма очереди для асинхронных вызовов
- **Влияние**: 
  - Нельзя отложить вызов плагина
  - Нет retry механизма
  - Нет circuit breaker
- **Будущее**: Можно добавить, но это усложняет систему

#### Ограниченная передача данных
- **Проблема**: Данные передаются через IPC (в subprocess режиме)
- **Влияние**: 
  - Большие объекты → медленная сериализация
  - Нет передачи бинарных данных напрямую
  - Нет streaming для больших файлов
- **Решение**: Можно использовать файлы/артефакты для больших данных

### 4. Отладка

#### Сложная трассировка
- **Проблема**: При ошибке в цепочке A→B→C нужно искать где именно
- **Влияние**: 
  - Логи разбросаны по разным процессам
  - Нужно собирать traceId вручную
  - Нет единого места для просмотра цепочки
- **Решение**: Нужен UI для просмотра трассировки

#### Ошибки в цепочках
- **Проблема**: Если B упал → A получает ошибку, но не знает детали
- **Влияние**: 
  - Нужно пробрасывать контекст ошибки
  - Сложнее понять что именно сломалось
- **Решение**: ErrorEnvelope уже содержит контекст, но нужен UI

### 5. Безопасность

#### Deny-by-default может быть слишком строгим
- **Проблема**: По умолчанию ничего не разрешено
- **Влияние**: 
  - Нужно явно разрешать каждый вызов
  - Может быть неудобно для разработки
- **Компромисс**: Безопасность vs удобство

#### Проверка прав только во время выполнения
- **Проблема**: Ошибки прав обнаруживаются только при запуске
- **Влияние**: 
  - Нет статической проверки разрешений
  - Нужно запускать чтобы увидеть ошибку
- **Решение**: Можно добавить валидацию манифеста при загрузке

### 6. Совместимость

#### Backward compatibility
- **Проблема**: Старые плагины без `invoke`/`artifacts` API не могут использовать новую систему
- **Влияние**: 
  - Нужно обновлять плагины
  - Fallback на FS работает, но не использует новую систему
- **Решение**: Постепенная миграция

#### Нет версионирования API
- **Проблема**: Если изменится формат `InvokeRequest` → ломается совместимость
- **Влияние**: 
  - Нужно обновлять все плагины одновременно
  - Нет обратной совместимости
- **Решение**: Нужно версионировать API

### 7. Ресурсы

#### Потребление памяти
- **Проблема**: Каждый `invoke()` создает новый процесс
- **Влияние**: 
  - При цепочке A→B→C→D = 4 процесса × 50-100MB = 200-400MB
  - При параллельных вызовах (fanOut=16) = 16 процессов × 100MB = 1.6GB
- **Решение**: Ограничения fanOut помогают, но все равно много памяти

#### Потребление CPU
- **Проблема**: Создание процесса + IPC коммуникация
- **Влияние**: 
  - Каждый `invoke()` = overhead на создание процесса
  - При частых вызовах = высокое потребление CPU
- **Решение**: Можно использовать пул процессов, но это усложняет

### 8. Тестирование

#### Сложнее тестировать цепочки
- **Проблема**: Нужно мокировать registry, брокеры, процессы
- **Влияние**: 
  - Тесты становятся сложнее
  - Нужно больше setup кода
  - Интеграционные тесты сложнее unit тестов
- **Решение**: Нужны хорошие тестовые утилиты

#### Нет изоляции в тестах
- **Проблема**: Тесты могут влиять друг на друга через registry
- **Влияние**: 
  - Нужно очищать registry между тестами
  - Параллельные тесты могут конфликтовать
- **Решение**: Нужен изолированный registry для каждого теста

## Компромиссы

### 1. Безопасность vs Производительность
- **Выбрали**: Безопасность (изоляция, проверка прав)
- **Платим**: Производительность (процессы, IPC, проверки)

### 2. Простота vs Функциональность
- **Выбрали**: Простота (синхронные вызовы, нет очереди)
- **Платим**: Ограниченная функциональность (нет async queue, retry)

### 3. Deny-by-default vs Удобство
- **Выбрали**: Deny-by-default (безопасность)
- **Платим**: Нужно явно разрешать все вызовы

### 4. Изоляция vs Ресурсы
- **Выбрали**: Изоляция (каждый invoke в новом процессе)
- **Платим**: Потребление памяти и CPU

## Что можно улучшить

### Краткосрочно (1-2 месяца)
1. ✅ IPC для subprocess режима
2. ✅ Кэширование разрешений
3. ✅ UI для просмотра трассировки
4. ✅ Валидация манифеста при загрузке

### Среднесрочно (3-6 месяцев)
1. Асинхронная очередь для вызовов
2. Retry механизм с exponential backoff
3. Circuit breaker для защиты от сбоев
4. Streaming для больших данных

### Долгосрочно (6+ месяцев)
1. Версионирование API
2. Пул процессов для переиспользования
3. Статическая проверка разрешений
4. Автоматическое определение зависимостей плагинов

## Итог

### Что работает хорошо
- ✅ Безопасность и изоляция
- ✅ Прозрачность и трассировка
- ✅ Понятные ошибки
- ✅ Простота использования (для конечного пользователя)

### Что нужно улучшить
- ⚠️ Производительность (IPC, процессы)
- ⚠️ Отладка (UI для трассировки)
- ⚠️ Функциональность (async queue, retry)
- ⚠️ Тестирование (утилиты, изоляция)

### Главный минус
**Сложность для разработчиков плагинов**: Нужно понимать систему разрешений, версионирование, формат вызовов. Но это цена за безопасность и изоляцию.

### Рекомендация
Для MVP текущая реализация достаточна. Для production нужно:
1. Реализовать IPC для subprocess режима
2. Добавить UI для трассировки
3. Улучшить производительность (кэширование, пул процессов)
4. Добавить async очередь и retry механизмы

